### COMMON DATA TYPES ###

# 32-byte BLAKE3 hash
type Blake3Digest32 data[32]

# Hash digest
type Digest union { Blake3Digest32 }

# ChaCha20 key
type ChaCha20Key data[32]

# Symmetric key
type SymKey union { ChaCha20Key }

# Curve25519 public key
type Curve25519PubKey data[32]

# Curve25519 private key
type Curve25519PrivKey data[32]

# Public key
type PubKey union { Curve25519PubKey }

# Private key
type PrivKey union { Curve25519PrivKey }

# Ed25519 signature
type Ed25519Sig data[64]

# Cryptographic signature
type Signature union { Ed25519Sig }

# Timestamp: absolute time in minutes since 2022-02-22 22:22 UTC
type Timestamp u32

# Relative time in seconds
type Seconds u8

# Relative time in minutes
type Minutes u8

# Relative time in hours
type Hours u8

# Relative time in days
type Days u8

# Relative time (e.g. delay from current time)
type RelTime union {
  | Seconds | Minutes | Hours | Days
}

### STORAGE OBJECTS ###

# Object ID
# BLAKE3 hash over the serialized Object with encrypted content
type ObjectId Digest

# Object reference
type ObjectRef struct {
  # Object ID
  id: ObjectId

  # Key for decrypting the Object
  key: SymKey
}

# Internal node of a Merkle tree
type InternalNode list<SymKey>

# Data chunk at a leaf of a Merkle tree
type DataChunk data

# Content of an Object
type ObjectContent union {
  # Internal node with references to children
  | InternalNode

  # Leaf node with encrypted data chunk
  | DataChunk
}

# List of ObjectId dependencies as encrypted Object content
type DepList union {
  list<ObjectId>
}

# Dependencies of an Object
type ObjectDeps union {
  # List of Object IDs (max. 8),
  | list<ObjectId>

  # Reference to an Object that contains a DepList
  | ObjectRef
}

# Immutable object with an encrypted chunk of data.
# Data is chunked and stored in a Merkle tree.
type Object union {
  struct {
    # Objects IDs for child nodes in the Merkle tree
    children: list<ObjectId>

    # Other objects this object depends on (e.g. Commit deps & acks)
    deps: ObjectDeps

    # Expiry time of this object and all of its children
    # when the object should be deleted by all replicas
    expiry: optional<Timestamp>

    # Object content
    # Encrypted using convergent encryption with ChaCha20:
    # - convergence_key: BLAKE3 derive_key ("LoFiRe Data BLAKE3 key",
    #                                       repo_pubkey + repo_secret)
    # - key: BLAKE3 keyed hash (convergence_key, plain_object)
    # - nonce: 0
    content: ObjectContent
  }
}

# Repository definition
# Published in root branch, where:
# - branch_pubkey: repo_pubkey
# - branch_secret: BLAKE3 derive_key ("LoFiRe Root Branch secret",
#                                     repo_pubkey + repo_secret)
type Repository union {
  struct {
    # Repo public key ID
    id: PubKey

    # List of branches
    branches: list<ObjectRef>

    # Whether or not to allow external requests
    allowExtRequests: bool

    # App-specific metadata
    metadata: data
  }
}

# Add a branch to the repository
type AddBranch union {
  struct {
    # Reference to the Branch
    branch: ObjectRef
  }
}

# Remove a branch from the repository
type RemoveBranch union {
  struct {
    # Reference to the Branch
    branch: ObjectRef
  }
}

# Commit object types
type CommitType enum {
  REPOSITORY ADD_BRANCH REMOVE_BRANCH
  BRANCH ADD_MEMBERS END_OF_BRANCH
  TRANSACTION SNAPSHOT COMMIT_ACK
}

# Member of a branch
type Member union {
  struct {
    # Member public key ID
    id: PubKey

    # Commit types the member is allowed to publish in the branch
    commitTypes: list<CommitType>

    # Application-specific metadata
    # (role, permissions, cryptographic material, etc)
    metadata: data
  }
}

# Branch definition
# First commit in a branch, signed by branch key
# In case of a fork, the commit deps indicate the previous branch heads
type Branch union {
  struct {
    # Branch public key ID
    id: PubKey

    # Pub/sub topic for publishing events
    topic: PubKey

    # Branch secret key
    secret: SymKey

    # Members with permissions
    members: list<Member>

    # Number of acks required for a commit to be valid
    quorum: map<CommitType><u32>

    # Delay to send explicit acks, if not enough implicit acks arrived by then
    ackDelay: RelTime

    # Tags for organizing branches within the repository
    tags: list<data>

    # App-specific metadata (validation rules, etc)
    metadata: data
  }
}

# Add members to an existing branch
# If a member already exists, it overwrites the previous definition,
# in that case this can only be used for adding new permissions,
# not to remove existing ones.
# The quorum and ackDelay can be changed as well
type AddMembers union {
  struct {
    # Members to add, with permissions
    members: list<Member>

    # New quorum
    quorum: optional<map<CommitType><u32>>

    # New ackDelay
    ackDelay: optional<RelTime>
  }
}

# End of branch
# No more commits accepted afterwards, only acks of this commit
# May reference a fork where the branch continues
# with possibly different members, permissions, validation rules.
type EndOfBranch union {
  struct {
    # (Encrypted) reference to forked branch (optional)
    fork: optional<ObjectRef>

    # Expiry time when all commits in the branch should be deleted
    expiry: Timestamp
  }
}

# Transaction with CRDT operations
type Transaction union {
  struct {
    # Transaction data
    content: data
  }
}

# Snapshot of a branch
# with a data structure computed from the commits at the specified head
type Snapshot union {
  struct {
    # Branch heads the snapshot was made from
    heads: list<ObjectId>

    # Snapshot data structure
    content: data
  }
}

# Acknowledgement of another commit
type Ack union {
  void
}

# Commit body, corresponds to CommitType
type CommitBody union {
  | Repository | AddBranch | RemoveBranch
  | Branch | AddMembers | EndOfBranch
  | Transaction | Snapshot | Ack
}

# Commit object
# Signed by branch key, or a member key authorized to publish this commit type
type Commit union {
  struct {
    content: struct {
      # Commit author
      author: PubKey

      # Author's commit sequence number in this branch
      seq: u32

      # Branch the commit belongs to
      branch: ObjectRef

      # Direct dependencies of this commit
      deps: list<ObjectRef>

      # Not directly dependent heads to acknowledge
      acks: list<ObjectRef>

      # Files the commit references
      refs: list<ObjectRef>

      # App-specific metadata (commit message, creation time, etc)
      metadata: data

      # Object with a CommitBody inside
      body: ObjectRef

      # Expiry time of the body object
      expiry: optional<Timestamp>
    }

    # Signature over the content by the author
    sig: Signature
  }
}

# A file stored in an Object
type File union {
  struct {
    contentType: data
    metadata: data
    content: data
  }
}

# Immutable data
type Data union {
  | Commit | CommitBody | File
}


### COMMON DATA TYPES FOR MESSAGES ###

type PeerId PubKey

# IP address
type IPv4 data[4]
type IPv6 data[16]
type IP union { IPv4 | IPv6 }
type MacAddr data[6]

type IPTransportProtocol enum { TLS QUIC }

type IPTransportAddr struct {
  ip: IP
  port: u16
  protocol: IPTransportProtocol
}

# Network address
type NetAddr union { IPTransportAddr }

# Bloom filter (variable size)
type BloomFilter struct {
  # Number of hash functions
  k: u8

  # Filter
  f: data
}

# Bloom filter (128 B)
# (m=1024; k=7; p=0.01; n=107)
type BloomFilter128 data[128]

# Bloom filter (1 KiB)
# (m=8192; k=7; p=0.01; n=855)
type BloomFilter1K data[1024]

### OVERLAY MESSAGES ###

# Overlay connection request
# Sent to an existing overlay member to initiate a session
type OverlayConnect union {
  void
}

# Overlay disconnection request
# Sent to a connected overlay member to terminate a session
type OverlayDisconnect union {
  void
}

# Topic advertisement by a publisher
# Flooded to all peers in overlay
# Creates subscription routing table entries
type TopicAdvert struct {
  content: struct {
    # Topic public key
    topic: PubKey

    # Peer public key
    peer: PeerId
  }

  # Signature over content by topic key
  sig: Signature
}

# Topic subscription request by a peer
# Forwarded towards all publishers along subscription routing table entries
# that are created by TopicAdverts
# Creates event routing table entries along the path
type SubReq struct {
  # Random ID generated by the subscriber
  id: u64

  # Topic public key
  topic: PubKey
}

# Topic subscription acknowledgement by a publisher
# Sent to all subscribers in an Event
type SubAck struct {
  # SubReq ID to acknowledge
  id: u64
}

# Topic unsubscription request by a subscriber
# A broker unsubscribes from upstream brokers
# when it has no more subscribers left
type UnsubReq struct {
  # Topic public key
  topic: PubKey
}

# Topic unsubscription acknowledgement
# Sent to the requestor in response to an UnsubReq
type UnsubAck struct {
  # Topic public key
  topic: PubKey
}

# Branch change notification
# Contains a chunk of a newly added Commit or File referenced by a commit.
type Change union {
  struct {
    # Object with encrypted content
    content: Object

    # Encrypted key for the Commit object in content
    # The key is encrypted using ChaCha20:
    # - key: BLAKE3 derive_key ("LoFiRe Event ObjectRef ChaCha20 key",
    #                           branch_pubkey + branch_secret + publisher_pubkey)
    # - nonce: commit_seq
    key: optional<SymKey>
  }
}

type EventBody union {
  | SubAck | Change
}

# Pub/sub event published in a topic
# Forwarded along event routing table entries
type Event union {
  struct {
    content: struct {
      # Pub/sub topic
      topic: PubKey

      # Publisher pubkey hash
      # BLAKE3 keyed hash over branch member pubkey
      # - key: BLAKE3 derive_key ("LoFiRe Event publisher BLAKE3 key",
      #                           repo_pubkey + repo_secret +
      #                           branch_pubkey + branch_secret)
      publisher: Digest

      # Commit sequence number of publisher
      seq: u32

      # Event body
      body: EventBody
    }

    # Signature over content by topic key
    sig: Signature
  }
}

# Object request by ID along the reverse path of a pub/sub topic
# from a subscriber to all publishers
type ObjectReqTopic union {
  struct {
    # Topic to forward the request in
    topic: PubKey

    # List of Object IDs to request
    ids: list<ObjectId>

    # Whether or not to include all children recursively in the response
    recursive: bool

    # List of Peer IDs the request traversed so far
    path: list<PeerId>
  }
}

# Object request by ID using a random walk
type ObjectReqRandom union {
  struct {
    # List of Object IDs to request
    ids: list<ObjectId>

    # Whether or not to include all children recursively in the response
    recursive: bool

    # Number of random nodes to forward the request to at each step
    fanout: u8

    # List of Peer IDs the request traversed so far
    path: list<PeerId>
  }
}

# Response to an Object request
# Follows request path with possible shortcuts
type ObjectResponse union {
  struct {
    # Response path
    path: list<PeerId>

    # Resulting Object(s)
    payload: list<Object>
  }
}

# Request latest events corresponding to the branch heads in a pub/sub topic
# In response an Event is sent for each commit chunk that belong to branch heads
# that are not present in the requestor's known heads
type BranchHeadsReq union {
  struct {
    # Topic public key of the branch
    topic: PubKey

    # Known heads
    knownHeads: list<ObjectId>
  }
}

# Branch synchronization request
# In response a stream of Objects are sent
# that are not present in the requestor's known heads and commits
type BranchSyncReq union {
  struct {
    # Heads to request, including all their deps
    heads: list<ObjectId>

    # Fully synchronized up until these commits
    knownHeads: list<ObjectId>

    # Known commit IDs since knownHeads
    knownCommits: BloomFilter
  }
}

# Request missed events for a pub/sub topic
# for the specified range of publisher sequence numbers
# In response an EventRes then a stream of Events are sent
type EventReq union {
  struct {
    # Topic public key
    topic: PubKey

    # Events needed by the requestor
    need: list<struct {
      # Publisher ID
      publisher:  Digest

      # First sequence number to request
      from: u32

      # Last sequence number to request
      to: u32
    }>
  }
}

# Response to an EventReq
type EventRes union {
  struct {
    # Events the responder has
    have: list<struct {
      # Publisher ID
      publisher: Digest

      # First sequence number to send
      from: u32

      # Last sequence number to send
      to: u32
    }>
  }
}

type OverlayRequest union {
  struct {
    # Request ID
    id: u64

    # Request content
    content: union {
      | EventReq
        | BranchHeadsReq
        | BranchSyncReq
    }
  }
}

type OverlayResponse union {
  struct {
    # Request ID
    id: u64

    # Result
    result: u8

    # Response content
    content: optional<union {
      | EventRes
        | Object
    }>
  }
}

# Peer advertisement
# Sent periodically across the overlay along random walks
type PeerAdvert union {
  struct {
    # Peer advertisement content
    content: struct {
      # Peer ID
      peer: PeerId

      # Topic subscriptions
      subs: BloomFilter128

      # Network addresses
      address: list<NetAddr>

      # Version number
      version: u16

      # App-specific metadata (profile, cryptographic material, etc)
      metadata: data
    }

    # Signature over content by peer's private key
    sig: Signature

    # Time-to-live, decremented at each hop
    ttl: u8
  }
}

# Overlay ID
# - for public overlays that need to be discovered by public key:
#   BLAKE3 hash over the repository public key
# - for private overlays:
#   BLAKE3 keyed hash over the repository public key
#   - key: BLAKE3 derive_key ("LoFiRe OverlayId BLAKE3 key", repo_secret)
type OverlayId Digest

# Oerlay session ID
# Used as a component for key derivation.
# Each peer generates it randomly when (re)joining the overlay network.
type SessionId u64

type OverlayMessageContent struct {
  content: union {
    | OverlayConnect | OverlayDisconnect
    | PeerAdvert | TopicAdvert
    | SubReq | UnsubReq | UnsubAck
    | Event
    | ObjectReqTopic | ObjectReqRandom
    | OverlayRequest | OverlayResponse
  }

  # Optional padding
  padding: data
}

# Overlay message
type OverlayMessage union {
  struct {
    # Overlay ID
    overlay: OverlayId

    # Session ID
    session: SessionId

    # Content encrypted with ChaCha20
    # - overlay_secret: BLAKE3 derive_key ("LoFiRe Overlay BLAKE3 key",
    #                                      repo_pubkey + repo_secret)
    # - key: BLAKE3 derive_key ("LoFiRe OverlayMessage ChaCha20 key",
    #                           overlay_secret + session_id)
    # - nonce: per-session message sequence number of sending peer
    content: OverlayMessageContent

    # BLAKE3 MAC
    # BLAKE3 keyed hash over the encrypted content
    # - key:  BLAKE3 derive_key ("LoFiRe OverlayMessage BLAKE3 key",
    #                            overlay_secret + session_id)
    mac: Digest
  }
}


### APPLICATION PROTOCOL ###

# Server hello sent upon a client connection
type ServerHello union {
  struct {
    # Nonce for ClientAuth
    nonce: data
  }
}

# Client authentication by a user's device
type ClientAuth union {
  struct {
    # Authentication data
    content: struct {
      # User pub key
      user: PubKey

      # Device pub key
      device: PubKey

      # Nonce from ServerHello
      nonce: data
    }

    # Signature by device key
    sig: Signature
  }
}

# Add user account
type AddUser union {
  struct {
    content: struct {

      # User pub key
      user: PubKey
    }

    # Signature by admin key
    sig: Signature
  }
}

# Remove user account
type DelUser union {
  struct {
    content: struct {

      # User pub key
      user: PubKey
    }

    # Signature by admin key
    sig: Signature
  }
}

# Authorize device key
type AuthorizeDeviceKey union {
  struct {
    # Authorization message content
    content: struct {
      # Device pub key
      device: PubKey
    }

    # Signature by user key
    sig: Signature
  }
}

# Revoke device key
type RevokeDeviceKey union {
  struct {
    # Revocation message content
    content: struct {
      # Device pub key
      device: PubKey
    }

    # Signature by user key
    sig: Signature
  }
}

# Request to join an overlay
type OverlayJoin union {
  struct {
    # Overlay secret
    secret: SymKey

    # Peers to connect to
    peers: list<PeerAdvert>
  }
}

# Request to leave an overlay
type OverlayLeave union {
  void
}

# Request an object by ID
type ObjectGet union {
  struct {
    # List of Object IDs to request
    ids: list<ObjectId>

    # Whether or not to include all children recursively
    includeChildren: bool

    # Topic the object is referenced from
    topic: optional<PubKey>
  }
}

# Request to store an object
type ObjectPut union {
  struct {
    object: Object
  }
}

# Request to pin an object
# Brokers maintain an LRU cache of objects,
# where old, unused objects might get deleted to free up space for new ones.
# Pinned objects are retained, regardless of last access.
# Note that expiry is still observed in case of pinned objects.
# To make an object survive its expiry,
# it needs to be copied with a different expiry time.
type ObjectPin union {
  struct {
    id: ObjectId
  }
}

# Request to unpin an object
type ObjectUnpin union {
  struct {
    id: ObjectId
  }
}

# Request to copy an object with a different expiry time
type ObjectCopy union {
  struct {
    id: ObjectId

    expiry: optional<Timestamp>
  }
}

# Request to delete an object
type ObjectDel union {
  struct {
    id: ObjectId
  }
}

# Request subscription to a topic
# For publishers a private key also needs to be provided
type TopicSub union {
  struct {
    # Topic to subscribe
    topic: PubKey

    # Topic private key for publishers
    key: optional<PrivKey>
  }
}

# Request unsubscription from a topic
type TopicUnsub union {
  struct {
    # Topic to unsubscribe
    topic: PubKey
  }
}

# Application request
type AppRequest struct {
  # Request ID
  id: u64

  # Request content
  content: union {
    | OverlayJoin | OverlayLeave
    | TopicSub | TopicUnsub
    | Event
    | ObjectGet | ObjectPut
    | ObjectPin | ObjectUnpin
    | ObjectCopy | ObjectDel
    | BranchHeadsReq | BranchSyncReq
  }
}

# Result codes
type Result enum { OK ERROR }

# Response to a request
type AppResponse struct {
  # Request ID
  id: u64

  # Result (incl but not limited to Result)
  result: u8
  content: optional<union {
    Object
  }>
}


# Application message for an overlay
type AppOverlayMessage struct {
  overlay: OverlayId
  content: union {
    | AppRequest | AppResponse
    | Event
  }
}

# Application message
type AppMessage struct {
  # Message content
  content: union {
    | ServerHello | ClientAuth
    | AddUser | DelUser
    | AuthorizeDeviceKey | RevokeDeviceKey
    | AppOverlayMessage
  }

  # Optional padding
  padding: data
}

### EXTERNAL REQUESTS ###

# Link to object(s) by ID from a repository that can be shared to non-members
# The request is sent to a node with a replica of the repository,
# The response includes the requested objects and all their children recursively,
# and optionally all object dependencies recursively.
type ExtObjectReq union {
  struct {
    # Repository to request the objects from
    repo: PubKey

    # List of Object IDs to request, including their children
    ids: list<ObjectId>

    # Whether or not to include all children recursively
    includeChildren: bool

    # Expiry time after which the link becomes invalid
    expiry: optional<Timestamp>
  }
}

# Branch heads request
type ExtBranchHeadsReq BranchHeadsReq

# Branch synchronization request
type ExtBranchSyncReq BranchSyncReq

# External request authenticated by a MAC
type ExtRequest struct {
  # Request ID
  id: u64

  # Request content
  content: union {
    | ExtObjectReq
    | ExtBranchHeadsReq
    | ExtBranchSyncReq
  }

  # BLAKE3 MAC over content
  # BLAKE3 keyed hash:
  # - key: BLAKE3 derive_key ("LoFiRe ExtRequest BLAKE3 key",
  #                           repo_pubkey + repo_secret)
  mac: Digest
}

# Response to an external request
type ExtResponse struct {
  # Request ID
  id: u64

  # Result code
  result: u8
}


### DIRECT MESSAGES ###

# Link/invitation to the repository
type RepoLink union {
  struct {
    # Repository public key ID
    id: PubKey

    # Repository secret
    secret: SymKey

    # Peers to connect to
    peers: list<PeerAdvert>
  }
}

# Owned repository with private key
type RepoKeys union {
  struct {
    # Repository private key
    key: PrivKey

    # Repository secret
    secret: SymKey

    # Peers to connect to
    peers: list<PeerAdvert>
  }
}

# Link to object(s) or to a branch from a repository
# that can be shared to non-members
type ObjectLink union {
  struct {
    # Request to send to an overlay peer
    req: ExtRequest

    # Keys for the requested objects
    keys: list<ObjectRef>
  }
}

### BROKER STORAGE ###

# A topic this node subscribed to in an overlay
type Topic union {
  struct {
    # Topic public key ID
    id: PubKey

    # Topic private key for publishers
    privKey: optional<PrivKey>

    # Set of branch heads
    heads: list<ObjectId>

    # Number of local users that subscribed to the topic
    users: u32
  }
}

# An overlay this node joined
type Overlay union {
  struct {
    # Overlay ID
    id: OverlayId

    # Overlay secret
    secret: SymKey

    # Known peers with connected flag
    peers: list<PeerAdvert>

    # Topics this node subscribed to in the overlay
    topics: list<Topic>

    # Number of local users that joined the overlay
    users: u32

    # Last access by any user
    lastAccess: Timestamp
  }
}

# User accounts
# stored as user_pubkey -> Account
type Account union {
  struct {
    # Authorized device pub keys
    authorizedKeys: list<PubKey>

    # Admins can add/remove user accounts
    admin: bool

    # Overlays joined
    overlays: list<Overlay>

    # Topics joined, with publisher flag
    topics: list<Topic>
  }
}
